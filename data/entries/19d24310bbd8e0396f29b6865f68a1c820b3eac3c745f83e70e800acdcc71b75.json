{"title":"Fetch API with progress","link":"https://www.llun.me/posts/dev/2021-01-30-fetch-api-with-progress/","date":1611964800000,"content":"\n      \n        <p>วันนี้มานั่งทำ <a href=\"https://github.com/llun/feeds\" target=\"_blank\">project feeds</a> ตัวเองต่อแล้วก็มี feature ที่แสดง progress เวลา load page หรือ categories เพราะบางที internet ช้ามันจะรู้สึกเหมือนว่าโปรแกรมมันค้าง ตอนเริ่มแรกสุดไม่มีปัญหานี้เพราะ generate feed entry ทุกหน้าเป็น static page แล้ว browser ทำเรื่อง loading ให้แต่พอเปลี่ยนมาเป็น single page app ที่โหลด feed entry ผ่าน fetch เรื่องนี้เลยกลายเป็นปัญหา</p>\n<p>Loading bar ตอนนี้ก็ทำง่ายๆ เป็นแถบอยู่บนสุดของหน้า ปัญหาคือจะแสดงว่าโหลดถึงไหนแล้วยังไง ตอนแรกที่คิดก็กะว่าจะทำ random progress แบบ Github เพราะไม่มีอะไรยุ่งยาก random เลขเอาแล้วเอา sequence function มาใส่ให้มันดูเหมือน load จริงแต่ดันไปเจอว่า <a href=\"https://javascript.info/fetch-progress\" target=\"_blank\">fetch api มีวิธีอ่าน bytes ที่ดาวโหลดมาแล้วเท่าไหร่กับ content length</a> เลยเปลี่ยนมาแสดง progress ตามที่โหลดจริงแทน</p>\n<h2>Fetch readable stream <a href=\"https://www.llun.me/posts/dev/2021-01-30-fetch-api-with-progress/#fetch-readable-stream\">#</a></h2>\n<p>ReadableStream เป็น stream interface ใน Javascript บน Browser ที่พึ่งรู้ว่ามี ลองไปดูใน <a href=\"https://caniuse.com/?search=readablestream\" target=\"_blank\">caniuse.com</a> แล้วพึ่งเห็นว่ามันมีตั้งแต่ Chrome 43 และ Safari 10 แล้ว! ตั้งแต่สมัย iPhone8 แล้ว fetch แปะ readable stream มากับ <code>response.body</code> ที่ return มาจาก <code>await fetch(url)</code> วิธีหาว่า fetch ดึงข้อมูลจาก url ที่ใส่ไปมาเท่าไหร่แล้วก็ง่ายๆ เอา ReadableStream ด้วย <code>response.body.getReader()</code> แล้ว loop เรียก read วนไป</p>\n<pre><code>async function loadData(url) {\n  const response = await fetch(url)\n  // ดึงมาว่าขนาดทั้งหมดของข้อมูลเท่าไหร่ ไว้คำนวน percentage\n  const contentLength = parseInt(\n    response.headers.get('Content-Length') || '0',\n    10\n  )\n\n\tconst reader = response.body.getReader()\n\t// Uint8Array spread ไม่ได้แล้วจะเอามาต่อกันก็ต้องรู้ขนาดทั้งหมดก่อน เลยต้องเอา chunk มาเก็บไว้ก่อนพร้อมกับหาขนาดทั้งหมดระหว่างอ่านมา\n\tlet totalRead = 0\n\tlet chunks = []\n\twhile (true) {\n\t  const { done, value } = await reader.read()\n\t  if (done) break\n\t  totalRead += value.length\n\t  chunks(value)\n\t  // ระหว่างอ่านมาก็ update progress bar ไปด้วย\n\t  updateProgress(totalRead, contentLength)\n\t}\n\n\t// อ่านมาครบแล้วก็เอาข้อมูลมาต่อ แต่ Uint8Array ไม่มี concat/push ตรงๆ เลยต้องสร้าง Uint8Array มาอีกอันกับขนาดทั้งหมดของข้อมูล\n\tconst flatten = new Uint8Array(totalRead)\n\t// ตอนแรกคิดว่าจะใช้ flatten.length แต่ length ที่คือมาคือ totalBytes เลยต้อกำหนด position เพิ่มขึ้นมาให้ต่อข้อมูลถูกจุด\n\tlet position = 0\n\tfor (const array in data) {\n\t\tflatten.set(array, position)\n\t\tposition += array.length\n\t}\n\t// ปิดท้ายด้วยเอา text decoder  มาอ่าน array พร้อมบอกว่าเป็นข้อมูลประเภทไหนจะได้แปลงถูก\n\tconst text = new TextDecoder('utf-8').decode(chunksAll)\n\treturn text\n}\n</code></pre>\n<p>บนนี้คือเอามาจาก <a href=\"https://javascript.info/fetch-progress\" target=\"_blank\">https://javascript.info/fetch-progress</a> ตรงๆ เลย</p>\n<p>Feature อีกอย่างที่ readable stream มีคือมัน cancel ได้! แต่ยังไม่ได้ลองเล่นว่ามันหยุดดาวโหลด content เมื่อสั่ง cancel หรือป่าว ตอนแรกที่หาไว้คือใช้ <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/AbortController\" target=\"_blank\">AbortController</a> แต่ถ้าสามารถ cancel ที่ request ได้เลยจะง่ายกว่าสั่งยกเลิกทั้ง page ไว้รอบหน้าลองแล้วได้ผลยังไงมาเขียนอีกที</p>\n\n        <p>\n          <a href=\"mailto:comment@llun.me?subject=Common on post https://www.llun.me/posts/dev/2021-01-30-fetch-api-with-progress/\">Send a comment</a>\n        </p>\n      \n    ","author":"Maythee Anegboonlap","siteTitle":"@llun story","siteHash":"e492a4c5a091b6624e5872d8d003bc73eb1166cc8f88db58c44e1f8dfb9c7252","entryHash":"19d24310bbd8e0396f29b6865f68a1c820b3eac3c745f83e70e800acdcc71b75","category":"Me"}