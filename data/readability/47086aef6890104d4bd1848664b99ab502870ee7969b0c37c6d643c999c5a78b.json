{"title":"Ruby and new Nodejs on AWS Lambda","link":"https://www.llun.me/posts/dev/2017-01-18-Ruby-and-new-nodejs-on-aws-lambda/","date":1484697600000,"content":"<div id=\"readability-page-1\" class=\"page\"><div><p>It seems I started playing this quite late, Amazon released this service in late 2014 but didn’t have a chance to play with because most of the project I’m working with are in (web) frontend only and then last month, got a project that can start everything on api side with AWS Lambda with AWS API gateway.</p><h2 id=\"first-try%2C\">First try, <a href=\"#first-try%2C\">#</a></h2><p>Q: can it use with Ruby.<br>A: Yes, however …</p><p>Current ReferralCandy stack are Ruby on Rails and most backend developer are Ruby developer, so if AWS Lambda can support ruby it would be nice, because everyone can start coding and move all project directly to AWS Lambda. However, Amazon doesn’t support Ruby yet, only node.js, java, pyton and C#, so I have to find another way.</p><p>There are few people tried running ruby on AWS Lambda already (Github project, <a href=\"https://github.com/lorennorman/ruby-on-lambda\" target=\"_blank\" rel=\"noopener\">ruby-on-lambda</a> or <a href=\"http://www.adomokos.com/2016/06/using-ruby-in-aws-lambda.html\">this post</a>) basic concept is, using any native supported language and fork ruby process inside. Fork process is actually can be anything, so it’s not limited to ruby only but the hard problem is because ruby is not supported by default, so AWS image that’s going to run the process doesn’t have that ruby binary program too. To use ruby, it need binary and package that build for linux similar to image AWS use to run AWS Lambda and also all dependencies that requires native also need to build or use library that compatible to linux image that AWS Lambda is using (which is Amazon Linux AMI 2016.09.1 or similar)</p><p>So I tried that way, by create new EC2 instance with Amazon Linux AMI 2016.09.1 image and download source and compile with below command</p><pre><code>./configure --prefix=/var/task/ruby --disable-install-doc\n</code></pre><p>I disable doc to make package smaller, I won’t read document on AWS Lambda anyway and put it under <code>/var/task/ruby</code> because AWS Lambda function will run inside that path. Then, install library that required native binary e.g. mysql with gem<br>gem install mysql2 activerecord oj<br>This will create gem package in <code>/var/task/ruby</code> which will need later in AWS Lambda. Other required files are native library that those package will use, basically mysql, will need to copy from system lib directory (in this linux image, it’s in <code>/usr/lib64</code> or somewhere similar) and put it in <code>/var/task/lib</code> which <code>LD_LIBRARY_PATH</code> points to in AWS Lambda image and then package all this back to my AWS Lambda function. I use <a href=\"http://apex.run/\">apex</a> for managing AWS Lambda deployment, so file structure become something like below</p><pre><code>root\n|-functions\n| |-awesome_ruby_task\n| |-ruby // ruby binary directory is here\n| |-lib // all native library are here\n| |-index.js // entry point for lambda\n| |-awesome.rb // awesome ruby task\n|-project.json\n</code></pre><p>and <code>index.js</code> is like below</p><pre><code>var spawn = require('child_process').spawn\nexports.handle = function (e, ctx, cb) {\nvar child = spawn('./ruby/bin/ruby', ['awesome.rb', JSON.stringify(e, null, 2), JSON.stringify(ctx, null, 2)])\nvar output = ''\nvar error = ''\nchild.stdout.on('data', function (data) { output += data })\nchild.stderr.on('data', function (data) { error += data })\n\nchild.on('close', function (code) {\nif (code !== 0 || error) {\nctx.done(error)\n}\nctx.done(null, JSON.parse(output))\n})\n}\n</code></pre><p>with my <code>awesome.rb</code></p><pre><code>require 'json'\nrequire 'yaml'\nrequire 'active_record'\n\nevent = JSON.parse(ARGV[0])\ndb_config = YAML::load(File.open('database.yml'))\nActiveRecord::Base.establish_connection(db_config)\n\nclass Data &lt; ActiveRecord::Base\nend\n\ndata = Data(event['data_id'])\n\nputs JSON.generate({\nid: data.id\n})\n</code></pre><p>Everything works but the request time is slow, with maximum memory (1.5 GB in lambda advance settings) I can get at most 500ms for warm boot (and cold boot is a lot slower ~6s.) So this is no go for us.</p><h2 id=\"second-try\">Second try <a href=\"#second-try\">#</a></h2><p>ok, ruby is no go (for now or at least required AWS native support or using transpiler like opal.rb which will revisit again later.) next, how’s about javascript.</p><p>Native javascript supported is also not that good for node.js, current <code>node.js</code> in AWS Lambda is still <code>Node 4.3</code>! that’s old. Current stable release is <code>6.9</code> and edge version is <code>7</code> already. The thing is, Javascript has something calls Babel which can convert any edge syntax to support syntax for old js engine. (<code>await/async</code> is a must for my team and I can understand how painful to switch to async style even <code>Promise</code> is making it nice already) Using babel slows down deploy time a bit but still acceptable.</p><p>Everything works fine, few weeks pass by after first AWS Lambda deployed and using in development stack, few issues raise in the cautions mode but will evaluate later when this small project go to production, here are list that will need to take care later</p><ul><li>Cold boot time is increasing when project size is get larger, this’s become problematic when adding more dependencies to the project.</li><li>Parallel request cause multiple cold boot container and this cannot control. In AWS Lambda control panel, only memory that can adjust and increase memory make lambda start faster but it also increase the cost of lambda. So current tricky solution is using cron to ping the function in parallel (to the number that expecting that function will get call in parallel.) This issue, somehow don’t see people talk about it that much.</li><li>Manually manage lambda functions is a pain, and this will getting more painful when having more lambda, so <a href=\"https://serverless.com/\" target=\"_blank\" rel=\"noopener\">apex</a> or <a href=\"https://serverless.com/\" target=\"_blank\" rel=\"noopener\">serverless</a> is a must.</li></ul><p>This is the current state of my experiment for this one and a half month and end this post here. Hopefully I will revisit on the lambda again, after this stack go to production and have more fun with it.</p></div></div>","author":"","siteTitle":"@llun story","siteHash":"e492a4c5a091b6624e5872d8d003bc73eb1166cc8f88db58c44e1f8dfb9c7252","entryHash":"47086aef6890104d4bd1848664b99ab502870ee7969b0c37c6d643c999c5a78b","category":"Me"}